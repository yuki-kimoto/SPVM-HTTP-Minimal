# Copyright (c) 2023 Yuki Kimoto
# MIT License

class HTTP::Tiny::Handle {
  use Fn;
  use IO::Socket::INET;
  use Sys::Socket::Constatnt as SOCKET;
  
  has timeout : rw int;
  has rbuf : string;
  has timeout : int;
  has max_line_size : int;
  has max_header_lines : int;
  has verify_SSL : int;
  has SSL_options : object[];
  
  static method new : HTTP::Tiny::Handle ($options : object[]) {
    
    my $self = new HTTP::Tiny::Handle;
    
    $options = Fn->merge_options(
      {
        rbuf             => "",
        timeout          => 60,
        max_line_size    => 16384,
        max_header_lines => 64,
        verify_SSL       => 0,
        SSL_options      => {},
      },
      $options
    );
    
    $self->{rbuf} = $options->{rbuf};
    $self->{timeout} = $options->{timeout};
    $self->{max_line_size} = $options->{max_line_size};
    $self->{max_header_lines} = $options->{max_header_lines};
    $self->{verify_SSL} = $options->{verify_SSL};
    $self->{SSL_options} = $options->{SSL_options};
    
    return $self;
  }

  method connect ($scheme : string, $host : string, $port : string, $peer : string) {
    
    if ($scheme eq "https") {
      $self->_assert_ssl;
    }
    
    my $fh = IO::Socket::INET->new(
        PeerHost  => $peer,
        PeerPort  => $port,
        LocalAddr => $self->{local_address},
        Proto     => "tcp",
        Type      => SOCK_STREAM,
        Timeout   => $self->{timeout},
    );
    $self->{fh} = $fh;
    
    if ($self->{keep_alive}) {
      unless ($self->{fh}->setsockopt(SOCKET->SOL_SOCKET, SOCKET->SO_KEEPALIVE, 1))) {
        $self->{fh}->close;
        die "Could not set SO_KEEPALIVE on socket: \"$!\"";
      }
    }
    
    if ($scheme eq "https") {
      $self->start_ssl($host);
    }
    
    $self->{scheme} = $scheme;
    $self->{host} = $host;
    $self->{peer} = $peer;
    $self->{port} = $port;
    $self->{pid} = $$;
    
    return $self;
  }
  
  method _assert_ssl : void {
    my $reason_ref = new string[1];
    
    my $ok = HTTP::Tiny->can_ssl($reason_ref);
    unless ($ok) {
      die $reason_ref->[0];
    }
  }

  method start_ssl : void ($host : string) {

=pod

    # As this might be used via CONNECT after an SSL session
    # to a proxy, we shut down any existing SSL before attempting
    # the handshake
    if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
        unless ( $self->{fh}->stop_SSL ) {
            my $ssl_err = IO::Socket::SSL->errstr;
            die(qq/Error halting prior SSL connection: $ssl_err/);
        }
    }

    my $ssl_args = $self->_ssl_args($host);
    IO::Socket::SSL->start_SSL(
        $self->{fh},
        %$ssl_args,
        SSL_create_ctx_callback => sub {
            my $ctx = shift;
            Net::SSLeay::CTX_set_mode($ctx, Net::SSLeay::MODE_AUTO_RETRY());
        },
    );

    unless ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
        my $ssl_err = IO::Socket::SSL->errstr;
        die(qq/SSL connection failed for $host: $ssl_err\n/);
    }

=cut

  }
}
