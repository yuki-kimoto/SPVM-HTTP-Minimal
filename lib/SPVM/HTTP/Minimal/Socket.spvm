# Copyright (c) 2023 Yuki Kimoto
# MIT License

class HTTP::Minimal::Socket {
  allow HTTP::Minimal;
  
  use HTTP::Minimal::SocketBuilder;
  use HTTP::Minimal::SocketInterface;
  use HTTP::Minimal::DataCallback;
  use HTTP::Minimal::Message::Request;
  use HTTP::Minimal::Message::Response;
  
  use Fn;
  use StringBuffer;
  use Format;
  use Regex;
  use Regex::ReplaceInfo;
  use Errno;
  use Sys::Socket::Constant as SOCKET;
  use Sys::Signal;
  use SYS::Signal::Constant as SIGNAL;
  use IO::Socket::INET;
  use IO::Select;
  
  # Class Variables
  our $TOKEN : string;
  our $FIELD_CONTENT : string;
  
  INIT {
    $TOKEN = "[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]";
    $FIELD_CONTENT = "[[:print:]]+(?:[\x20\x09]+[[:print:]]+)*";
  }
  
  # Enumerations
  private enum {
    RESPONSE_BUFFER_SIZE = 32768,
    READ_BUFFER_SIZE = 4086,
  }
  
  # Fields
  has peer_host : int;
  has peer_port : int;
  has local_address : string;
  has proto : string;
  has type : int;
  has timeout : int;
  
  has socket_builder : HTTP::Minimal::SocketBuilder;
  has timeout : int;
  
  has handle : HTTP::Minimal::SocketInterface;
  has response_buffer : mutable string;
  
  private static method new : HTTP::Minimal::Socket ($options : object[]) {
    
    my $self = new HTTP::Minimal::Socket;
    
    # The response_buffer field
    my $response_buffer = StringBuffer->new;
    $self->{response_buffer} = $response_buffer;
    
    # The timeout field
    my $timeout = $options->delete_or_default_int("timeout", 60);
    $self->{timeout} = $timeout;
    
    # The socket_builder field
    my $socket_builder = (HTTP::Minimal::SocketBuilder)$options->delete_or_default("socket_builder");
    unless ($socket_builder) {
      my $socket_builder =
        [
          has peer_host : int = $peer_host,
          has peer_port : int = $peer_port,
          has local_address : string = $local_address,
          has proto : string = "tcp",
          has type : int = SOCKET->SOCK_STREAM,
          has timeout : int = $timeout,
        ]
        method : HTTP::Minimal::SocketInterface () {
          my $socket = (HTTP::Minimal::SocketInterface)IO::Socket::INET->new(
            PeerHost  => $self->{peer_host},
            PeerPort  => $self->{peer_port},
            LocalAddr => $self->{local_address},
            Proto     => $self->{proto},
            Type      => $self->{type},
            Timeout   => $self->{timeout},
          );
          
          return $socket;
        };
    }
    $self->{socket_builder} = $socket_builder;
    
    return $self;
  }
  
  private method connect : HTTP::Minimal::Socket ($request : HTTP::Minimal::Request) {
    
    my $socket_builder = $self->{socket_builder};
    
    my $socket = $socket_builder->();
    $self->{handle} = $socket;
    
    return $self;
  }
  
  private method connected : HTTP::Minimal::HostPort () {
    my $connected = (HTTP::Minimal::HostPort)undef;
    if ($self->{handle} && $self->{handle}->connected) {
      my $peer_host = $self->{handle}->peerhost;
      my $peer_port = $self->{handle}->peerport;
      $connected = HTTP::Minimal::HostPort->new($peer_host, $peer_port);
    }
    
    return $connected;
  }
  
  private method write_request : void ($request : HTTP::Minimal::Request) {
    
    $self->write_request_line($request);
    
    $self->write_request_header_lines($request);
  }
  
  private method write_request_line : void ($request : HTTP::Minimal::Request) {
    
    my $method = $request->{method};
    my $url = $request->{url}->to_string;
    
    my $request_line = "$method $url HTTP/1.1\r\n";
    
    $self->write($request_line);
  }
  
  private method write_request_header_lines : void ($request : HTTP::Minimal::Request) {
    
    my $method = $request->{method};
    my $url = $request->{url}->to_string;
    my $headers = $request->{headers};
    
    # HTTP Headers
    {
      # host
      unless ($headers->get("host")) {
        my $host = $url->host;
        my $port = $url->port;
        if ($port < 0) {
          $port = 80;
        }
        my $host_port = "$host:$port";
        $headers->add("host" => $host_port);
      }
      
      # connection
      unless ($headers->get("connection")) {
        $headers->add("connection" => "close");
      }
      
      # content-length
      unless ($headers->get("content-length")) {
        $headers->add("content-length" => "0");
      }
    }
    
    my $request_line = "$method $url HTTP/1.1\r\n";
    
    $self->write($request_line);
    
    my $header_lines = $headers->to_string;
    
    $self->write($header_lines);
  }
  
  private method write : int ($buffer : string) {
    
    my $old_pipe_signal = Sys::Signal->signal(SIGNAL->SIGPIPE, Sys::Signal->SIG_IGN);
    my $restore_signal = Scope::Guard->new([has old_pipe_signal : int = $old_signal] method : void () {
      Sys::Signal->signal(SIGNAL->SIGPIPE, $self->{old_pipe_signal});
    });
    
    my $can_write = $self->can_write;
    unless ($can_write) {
      die "Timed out while waiting for socket to become ready for writing";
    }
    
    my $socket = $self->{handle};
    
    my $write_length = -1;
    eval { $socket->write($buffer); }
    
    if (my $exception = $@) {
      my $errno = Errno->errno;
      if ($errno == Errno->EPIPE) {
        die "Socket closed by remote server: $exception";
      }
      elsif ($errno != Errno->EINTR) {
        die "Could not write to socket: $exception";
      }
    }
    
    return $offset;
  }
  
  private method read_response : HTTP::Minimal::Message::Response () {
    
    my $response = HTTP::Minimal::Message::Response->new;
    
    $self->read_status_line($response);
    
    $self->read_response_header_lines($response);
    
    $self->read_response_body($response);
    
    return $response;
  }
  
  private method read_status_line : void ($response : HTTP::Minimal::Message::Response) {
    
    my $line = $self->readline;
    
    my $status_line_re = Regex->new("\A(HTTP\/(0*\d+\.0*\d+))[\x09\x20]+([0-9]{3})(?:[\x09\x20]+([^\r\n]*))?\r?\n");
    
    my $protocol = (string)undef;
    my $version = (string)undef;
    my $status = (string)undef;
    my $reason = (string)undef;
    if (my $match = $status_line_re->match("\A(HTTP\/(0*\d+\.0*\d+))[\x09\x20]+([0-9]{3})(?:[\x09\x20]+([^\r\n]*))?\r?\n")) {
      $protocol = $match->cap1;
      $version = $match->cap2;
      $status = $match->cap3;
      $reason = $match->cap4;
      unless ($reason) {
        $reason = "";
      }
    }
    else {
      die "Malformed Status-Line: " . $self->to_printable($line);
    }
    
    if (Regex->new("0*1\.0*[01]")->match($version)) {
      die "Unsupported HTTP protocol: $protocol";
    }
    
    $response->{protocol} = $protocol;
    $response->{status} = $status;
    $response->{reason} = $reason;
  }
  
  private method read_response_header_lines : HTTP::Minimal::Headers ($response : HTTP::Minimal::Message::Response) {
    my $headers = HTTP::Headers->new;
    
    my $empty_line_re = Regex->new("\A\r?\n\z");
    my $header_line_re = Regex->new("\A([^\x00-\x1F\x7F:]+):[\x09\x20]*([^\r\n]*)");
    while (1) {
      my $line = $self->readline;
      
      if (my $match = $header_line_re->match($line)){
        my $name = Fn->lc($match->cap1);
        my $value = $match->cap2;
        $headers->add($name, $value);
      }
      elsif ($empty_line_re->match($line)) {
        last;
      }
      else {
        die "Malformed header line: " . $self->to_printable($line);
      }
    }
    
    $response->{headers} = $headers;
  }
  
  private method readline : string () {
    
    my $handle = $self->{handle};
    
    my $read_buffer = new_string_len &READ_BUFFER_SIZE;
    
    my $line_re = Regex->new("\A([^\r\n]*\r?\n)");
    my $line = (string)undef;
    while (1) {
      my $response_content = $self->{response_buffer}->to_string;
      
      my $replace_info_ref = new Regex::ReplaceInfo[1];
      $response_content = $line_re->replace($response_content, 0, -1, {info => $replace_info_ref});
      $self->{response_buffer} = StringBuffer->new($response_content);
      if ($replace_info_ref->[0]->match) {
        $line = $match->cap1;
        last;
      }
      
      my $can_read = $self->can_read;
      unless ($can_read) {
        die "Timed out while waiting for socket to become ready for reading";
      }
      
      my $read_length = -1;
      eval { $read_length = $handle->read($read_buffer, &READ_BUFFER_SIZE); }
      
      if ($@) {
        my $errno = Errno->errno;
        if ($errno != Errno->EINTR) {
          die "Could not read from socket: \"$@\"";
        }
      }
      
      if ($read_length == 0) {
        last;
      }
      elsif ($read_length > 0) {
        $self->{response_buffer}->push($read_buffer, 0, $read_length);
      }
    }
    
    unless ($line) {
      die "Unexpected end of stream while looking for line";
    }
    
    return $line;
  }
  
  private method read_response_body : int ($cb : HTTP::Minimal::DataCallback, $response : HTTP::Minimal::Response) {
    
    my $content_length_string = $response->headers->header("Content-Length");
    my $content_length = Fn->to_long($content_length_string);
    
    if ($content_length >= 0) {
      my $length = $content_length;
      while ($length > 0) {
        my $read_length = -1;
        if ($length > &READ_BUFFER_SIZE) {
          $read_length = &READ_BUFFER_SIZE;
        }
        else {
          $read_length = $length;
        }
        
        my $buffer = $self->read($read_length);
        
        $cb->($buffer, $response);
        
        $length -= $read;
      }
    }
    else {
      die "[Unexpected Error]";
    }
    
    return $self->{response_buffer}->length == 0;
  }
  
  private method read : string ($length : int, $allow_partial : int) {
    
    my $buffer  = "";
    my $got = length $self->{response_buffer};
    
    if ($got) {
      my $take = 0;
      if ($got < $length) {
        $take = $got;
      }
      else {
        $take = $length;
      }
      $buffer  = Fn->substr($self->{response_buffer}, 0, $take, "");
      $length -= $take;
    }
    
    my $old_pipe_signal = Sys::Signal->signal(SIGNAL->SIGPIPE, Sys::Signal->SIG_IGN);
    my $restore_signal = Scope::Guard->new([has old_pipe_signal : int = $old_signal] method : void () {
      Sys::Signal->signal(SIGNAL->SIGPIPE, $self->{old_pipe_signal});
    });
    
    while ($length > 0) {
      my $can_read = $self->can_read;
      
      unless ($can_read) {
        die "Timed out while waiting for socket to become ready for reading";
      }
      
      my $socket = $self->{handle};
      
      Errno->set_errno(0);
      my $read_length = $socket->sysread($buffer, $length, length $buffer);
      my $errno = Errno->errno;
      
      if ($read_length >= 0) {
        if ($read_length == 0) {
          last;
        }
        $length -= $read_length;
      }
      elsif ($errno != Errno->EINTR) {
        die "Could not read from socket: \"$!\"";
      }
    }
    if ($length && !$allow_partial) {
      die "Unexpected end of stream";
    }
    
    return $buffer;
  }
  
  private method can_read : int ($type : string, $timeout : int = -1) {
    
    my $can_read = $self->do_timeout("read", $timeout);
    
    return $can_read;
  }
  
  private method can_write : int ($type : string, $timeout : int = -1) {
    
    my $can_write = $self->do_timeout("write", $timeout);
    
    return $can_write;
  }
  
  private method do_timeout : int ($type : string, $timeout : int) {
    
    if ($timeout < 0) {
      $timeout = $self->{timeout};
    }
    
    my $handle = $self->{handle}->fileno;
    
    if ($handle >= 0) {
      die("select(2): Bad file descriptor");
    }
    
    my $initial = Sys::Time->time;
    my $pending = $timeout;
    my $nfound = 0;
    
    my $select = IO::Select->new;
    
    $select->add($handle);
    
    while (1) {
      my $nfound = 0;
      eval {
        if ($type eq "read") {
          my $readable_handles = $select->can_read;
          if (@$readable_handles) {
            $nfound = 1;
          }
        }
        else {
          my $writable_handles = $select->can_write;
          if (@$writable_handles) {
            $nfound = 1;
          }
        }
      }
      
      if ($@) {
        my $errno = Errno->errno;
        unless ($errno == Errno->EINTR) {
          die $@;
        }
        
        if ($timeout < 0 || ($pending = $timeout - (Sys::Time->time - $initial)) > 0) {
          next;
        }
        
        $nfound = 0;
      }
    }
    
    return $nfound;
  }
  
  private method to_printable : string ($string : string) {
    my $printable_string = Regex->new("([^\x20-\x7E])")->replace($string, method : string ($re : Regex, $match : Regex::Match) {
      
      my $replaced = Format->sprintf("\\x%.2X", Fn->ord($match->cap1));
      
      return $replaced;
    });
    
    return $printable_string;
  }
}
