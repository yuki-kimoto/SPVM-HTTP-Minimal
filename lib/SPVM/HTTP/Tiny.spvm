# Copyright (c) 2023 Yuki Kimoto
# MIT License

class HTTP::Tiny {
  version "0.001_001";
  
  use Fn;
  use Regex;
  use Hash;
  use Sys;
  use Format;
  use Sys::Time::Tm;
  use HTTP::Tiny::Handle;
  use HTTP::Tiny::Error;
  use HTTP::Tiny::Response;
  use HTTP::Tiny::Headers;
  use HTTP::TIny::URL;
  
  has agent : ro string;
  has timeout : ro int;
  has handle : HTTP::Tiny::Handle;
  
  static method new : HTTP::Tiny ($options : object[] = undef) {
    
    my $options_h = Hash->new($options);
    
    my $self = new HTTP::Tiny;
    
    # timeout
    $self->{timeout} = $options_h->delete_or_default_int("timeout", 60);
    
    # agent
    my $agent = $options_h->delete_or_default_string("agent");
    if ($agent) {
      if (Regex->new(" $")->match($agent)) {
        $agent .= $self->_create_default_agent;
      }
    }
    else {
      $agent = $self->_create_default_agent;
    }
    
    $self->{agent} = $agent;
    
    return $self;
  }
  
  method get : HTTP::Response ($url : string|HTTP::Tiny::URL, $options : object[] = undef) {
    my $response = $self->request("GET", $url, $options);
    return $response;
  }
  
  method request : Hash ($method : string, $url : string|HTTP::Tiny::URL, $options : object[])  {
    
    unless ($url isa string || $url ias HTTP::Tiny::URL) {
      die "The \$url msut be a string or HTTP::Tiny::URL object";
    }
    
    my $url_object = (HTTP::Tiny::URL)undef;
    if ($url ias string) {
      $url_object = HTTP::Tiny::URL->parse((string)$url);
    }
    else {
      $url_object = $url;
    }
    
    my $request = HTTP::Tiny::Message::Request->new({
      method    => $method,
      url => $url_object;,
      headers   => HTTP::Tiny::Headers->new,
    });
    
    my $handle = $self->_open_handle( $request, $scheme, $host, $port, $peer );
    
    $self->_prepare_headers_and_cb($request, $options, $url, $auth);
    
    $handle->write_request($request);
    
    my $response = HTTP::Tiny::Message::Response->new;
    
    $response->{success} = substr( $response->{status}, 0, 1 ) eq '2';
    $response->{url} = $url;
    
    return $response;
  }

  private method _open_handle : HTTP::Tiny::Handle ($request : string, $scheme : string, $host : string, $port : string, $peer : string) {
    
    my $handle  = HTTP::Tiny::Handle->new({
      timeout         => $self->{timeout},
      local_address   => $self->{local_address},
      keep_alive      => $self->{keep_alive}
    });
    
    if ($self->{_has_proxy}{$scheme} && ! grep { $host =~ /\Q$_\E$/ } @{$self->{no_proxy}}) {
      return $self->_proxy_connect( $request, $handle );
    }
    else {
      return $handle->connect($scheme, $host, $port, $peer);
    }
  }
  
  private method _create_default_agent : string () {
    
    my $default_agent = "SPVM HTTP::Tiny";
    
    my $version = Fn->get_version_string("HTTP::Tiny");
    
    $default_agent .= "/$version";
    
    return $default_agent;
  }
  
  method _prepare_headers_and_cb : void () {
      my ($self, $request, $args, $url, $auth) = @_;

      for ($self->{default_headers}, $args->{headers}) {
          next unless defined;
          while (my ($k, $v) = each %$_) {
              $request->{headers}{lc $k} = $v;
              $request->{header_case}{lc $k} = $k;
          }
      }

      if (exists $request->{headers}{'host'}) {
          die(qq/The 'Host' header must not be provided as header option\n/);
      }

      $request->{headers}{'host'}         = $request->{host_port};
      $request->{headers}{'user-agent'} ||= $self->{agent};
      $request->{headers}{'connection'}   = "close"
          unless $self->{keep_alive};

      if ( defined $args->{content} ) {
          if ( ref $args->{content} eq 'CODE' ) {
              if ( exists $request->{'content-length'} && $request->{'content-length'} == 0 ) {
                  $request->{cb} = sub { "" };
              }
              else {
                  $request->{headers}{'content-type'} ||= "application/octet-stream";
                  $request->{headers}{'transfer-encoding'} = 'chunked'
                    unless exists $request->{headers}{'content-length'}
                    || $request->{headers}{'transfer-encoding'};
                  $request->{cb} = $args->{content};
              }
          }
          elsif ( length $args->{content} ) {
              my $content = $args->{content};
              if ( $] ge '5.008' ) {
                  utf8::downgrade($content, 1)
                      or die(qq/Wide character in request message body\n/);
              }
              $request->{headers}{'content-type'} ||= "application/octet-stream";
              $request->{headers}{'content-length'} = length $content
                unless $request->{headers}{'content-length'}
                    || $request->{headers}{'transfer-encoding'};
              $request->{cb} = sub { substr $content, 0, length $content, '' };
          }
          $request->{trailer_cb} = $args->{trailer_callback}
              if ref $args->{trailer_callback} eq 'CODE';
      }
      
      return;
  }
  
  private method _prepare_data_cb ($response : HTTP::Tiny::Response, $options_h : Hash) {
    my $data_cb = $options_h->get("data_callback");
    
    $response->{content} = "";
    
    if (!$data_cb || $response->{status} !~ /^2/) {
      if (defined $self->{max_size}) {
        $data_cb = sub {
          $_[1]->{content} .= $_[0];
          die(qq/Size of response body exceeds the maximum allowed of $self->{max_size}\n/)
            if length $_[1]->{content} > $self->{max_size};
        };
      }
      else {
        $data_cb = sub { $_[1]->{content} .= $_[0] };
      }
    }
    
    return $data_cb;
  }
}
