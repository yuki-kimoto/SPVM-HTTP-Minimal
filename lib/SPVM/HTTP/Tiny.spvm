# Copyright (c) 2023 Yuki Kimoto
# MIT License

class HTTP::Tiny {
  version "0.001_001";
  
  use Fn;
  use Regex;
  use Hash;
  use Sys;
  use Format;
  use Sys::Time::Tm;
  use HTTP::Tiny::Socket;
  use HTTP::Tiny::Error;
  use HTTP::Tiny::Response;
  use HTTP::Tiny::Headers;
  use HTTP::TIny::URL;
  use HTTP::Tiny::HostPort;
  
  has agent : ro string;
  has timeout : ro int;
  has handle : HTTP::Tiny::Socket;
  
  static method new : HTTP::Tiny ($options : object[] = undef) {
    
    my $options_h = Hash->new($options);
    
    my $self = new HTTP::Tiny;
    
    # timeout
    $self->{timeout} = $options_h->delete_or_default_int("timeout", 60);
    
    # agent
    my $agent = $options_h->delete_or_default_string("agent");
    if ($agent) {
      if (Regex->new(" $")->match($agent)) {
        $agent .= $self->_create_default_agent;
      }
    }
    else {
      $agent = $self->_create_default_agent;
    }
    
    $self->{agent} = $agent;
    
    return $self;
  }
  
  method get : HTTP::Response ($url : string|HTTP::Tiny::URL, $options : object[] = undef) {
    my $response = $self->request("GET", $url, $options);
    return $response;
  }
  
  method request : Hash ($method : string, $url : string|HTTP::Tiny::URL, $options : object[])  {
    
    my $options_h = Hash->new($options);
    
    unless ($url isa string || $url ias HTTP::Tiny::URL) {
      die "The \$url msut be a string or HTTP::Tiny::URL object";
    }
    
    my $url_object = (HTTP::Tiny::URL)undef;
    if ($url ias string) {
      $url_object = HTTP::Tiny::URL->parse((string)$url);
    }
    else {
      $url_object = $url;
    }
    
    # HTTP Header
    my $headers = HTTP::Tiny::Headers->new;
    my $host = $url_object->host;
    my $port = $url_object->port;
    if ($port < 0) {
      $port = 80;
    }
    $headers->add("Host" => "$host:$port");
    $headers->add("User-Agent" => $self->{agent});
    $headers->add("Connection" => "close");
    
    my $request = HTTP::Tiny::Message::Request->new({
      method    => $method,
      url => $url_object;,
      headers   => $headers,
    });
    
    my $handle  = HTTP::Tiny::Socket->new({
      timeout => $self->{timeout},
      data_callback => $options_h->get("data_callback"),
    });
    
    $handle->connect($request);
    
    $handle->write_request($request);
    
    my $response = $handle->read_response;
    
    return $response;
  }

  private method _create_default_agent : string () {
    
    my $default_agent = "SPVM HTTP::Tiny";
    
    my $version = Fn->get_version_string("HTTP::Tiny");
    
    $default_agent .= "/$version";
    
    return $default_agent;
  }
}
