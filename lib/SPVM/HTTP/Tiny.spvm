# Copyright (c) 2023 Yuki Kimoto
# MIT License

class HTTP::Tiny {
  version "0.001_001";
  
  use Fn;
  use Regex;
  use HTTP::Tiny::CookieJar::Interface;
  use HTTP::Tiny::Handle;
  
  has default_headers : string[];
  has http_proxy : string;
  has https_proxy : string;
  has keep_alive : int;
  has local_address : string;
  has max_redirect : int;
  has max_size : int;
  has proxy : string;
  has cookie_jar : HTTP::Tiny::CookieJar::Interface;
  has SSL_options : object[];
  has verify_SSL : int;
  has agent : ro string;
  has timeout : ro int;
  has handle : HTTP::Tiny::Handle;
  
  method set_agent : void ($agent : string) {
    
    if ($agent && Regex->new(" $")->match($agent)) {
      $agent = $agent . $self->_agent;
    }
    
    $self->{agent} = $agent;
  }
  
  private method _agent : string () {
    
    my $default_agent = "HTTP-Tiny";
    
    my $version = Fn->get_version_string("HTTP::Tiny");
    
    $default_agent .= "/$version";
    
    return $default_agent;
  }
  
  method set_timeout : void ($timeout : int) {
    $self->{timeout} = $timeout;
    if ($self->{handle}) {
      $self->{handle}->set_timeout($timeout);
    }
  }
 
}

=pod

  method new {
      my($class, %args) = @_;

      my $self = {
          max_redirect => 5,
          timeout      => defined $args{timeout} ? $args{timeout} : 60,
          keep_alive   => 1,
          verify_SSL   => $args{verify_SSL} || $args{verify_ssl} || 0, # no verification by default
          no_proxy     => $ENV{no_proxy},
      };

      bless $self, $class;

      $class->_validate_cookie_jar( $args{cookie_jar} ) if $args{cookie_jar};

      for my $key ( @attributes ) {
          $self->{$key} = $args{$key} if exists $args{$key}
      }

      $self->agent( exists $args{agent} ? $args{agent} : $class->_agent );

      $self->_set_proxies;

      return $self;
  }

  method _set_proxies {
      my ($self) = @_;

      # get proxies from %ENV only if not provided; explicit undef will disable
      # getting proxies from the environment

      # generic proxy
      if (! exists $self->{proxy} ) {
          $self->{proxy} = $ENV{all_proxy} || $ENV{ALL_PROXY};
      }

      if ( defined $self->{proxy} ) {
          $self->_split_proxy( 'generic proxy' => $self->{proxy} ); # validate
      }
      else {
          delete $self->{proxy};
      }

      # http proxy
      if (! exists $self->{http_proxy} ) {
          # under CGI, bypass HTTP_PROXY as request sets it from Proxy header
          local $ENV{HTTP_PROXY} = ($ENV{CGI_HTTP_PROXY} || "") if $ENV{REQUEST_METHOD};
          $self->{http_proxy} = $ENV{http_proxy} || $ENV{HTTP_PROXY} || $self->{proxy};
      }

      if ( defined $self->{http_proxy} ) {
          $self->_split_proxy( http_proxy => $self->{http_proxy} ); # validate
          $self->{_has_proxy}{http} = 1;
      }
      else {
          delete $self->{http_proxy};
      }

      # https proxy
      if (! exists $self->{https_proxy} ) {
          $self->{https_proxy} = $ENV{https_proxy} || $ENV{HTTPS_PROXY} || $self->{proxy};
      }

      if ( $self->{https_proxy} ) {
          $self->_split_proxy( https_proxy => $self->{https_proxy} ); # validate
          $self->{_has_proxy}{https} = 1;
      }
      else {
          delete $self->{https_proxy};
      }

      # Split no_proxy to array reference if not provided as such
      unless ( ref $self->{no_proxy} eq 'ARRAY' ) {
          $self->{no_proxy} =
              (defined $self->{no_proxy}) ? [ split /\s*,\s*/, $self->{no_proxy} ] : [];
      }

      return;
  }

  for my $sub_name ( qw/get head put post patch delete/ ) {
      my $req_method = uc $sub_name;
      no strict 'refs';
      eval <<"HERE"; ## no critic
      method $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or _croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  HERE
  }

  method post_form {
      my ($self, $url, $data, $args) = @_;
      (@_ == 3 || @_ == 4 && ref $args eq 'HASH')
          or _croak(q/Usage: $http->post_form(URL, DATAREF, [HASHREF])/ . "\n");

      my $headers = {};
      while ( my ($key, $value) = each %{$args->{headers} || {}} ) {
          $headers->{lc $key} = $value;
      }

      return $self->request('POST', $url, {
              # Any existing 'headers' key in $args will be overridden with a
              # normalized version below.
              %$args,
              content => $self->www_form_urlencode($data),
              headers => {
                  %$headers,
                  'content-type' => 'application/x-www-form-urlencoded'
              },
          }
      );
  }

  method mirror {
      my ($self, $url, $file, $args) = @_;
      @_ == 3 || (@_ == 4 && ref $args eq 'HASH')
        or _croak(q/Usage: $http->mirror(URL, FILE, [HASHREF])/ . "\n");

      if ( exists $args->{headers} ) {
          my $headers = {};
          while ( my ($key, $value) = each %{$args->{headers} || {}} ) {
              $headers->{lc $key} = $value;
          }
          $args->{headers} = $headers;
      }

      if ( -e $file and my $mtime = (stat($file))[9] ) {
          $args->{headers}{'if-modified-since'} ||= $self->_http_date($mtime);
      }
      my $tempfile = $file . int(rand(2**31));

      require Fcntl;
      sysopen my $fh, $tempfile, Fcntl::O_CREAT()|Fcntl::O_EXCL()|Fcntl::O_WRONLY()
         or _croak(qq/Error: Could not create temporary file $tempfile for downloading: $!\n/);
      binmode $fh;
      $args->{data_callback} = method { print {$fh} $_[0] };
      my $response = $self->request('GET', $url, $args);
      close $fh
          or _croak(qq/Error: Caught error closing temporary file $tempfile: $!\n/);

      if ( $response->{success} ) {
          rename $tempfile, $file
              or _croak(qq/Error replacing $file with $tempfile: $!\n/);
          my $lm = $response->{headers}{'last-modified'};
          if ( $lm and my $mtime = $self->_parse_http_date($lm) ) {
              utime $mtime, $mtime, $file;
          }
      }
      $response->{success} ||= $response->{status} eq '304';
      unlink $tempfile;
      return $response;
  }

  my %idempotent = map { $_ => 1 } qw/GET HEAD PUT DELETE OPTIONS TRACE/;

  method request {
      my ($self, $method, $url, $args) = @_;
      @_ == 3 || (@_ == 4 && ref $args eq 'HASH')
        or _croak(q/Usage: $http->request(METHOD, URL, [HASHREF])/ . "\n");
      $args ||= {}; # we keep some state in this during _request

      # RFC 2616 Section 8.1.4 mandates a single retry on broken socket
      my $response;
      for ( 0 .. 1 ) {
          $response = eval { $self->_request($method, $url, $args) };
          last unless $@ && $idempotent{$method}
              && $@ =~ m{^(?:Socket closed|Unexpected end|SSL read error)};
      }

      if (my $e = $@) {
          # maybe we got a response hash thrown from somewhere deep
          if ( ref $e eq 'HASH' && exists $e->{status} ) {
              $e->{redirects} = delete $args->{_redirects} if @{ $args->{_redirects} || []};
              return $e;
          }

          # otherwise, stringify it
          $e = "$e";
          $response = {
              url     => $url,
              success => q{},
              status  => 599,
              reason  => 'Internal Exception',
              content => $e,
              headers => {
                  'content-type'   => 'text/plain',
                  'content-length' => length $e,
              },
              ( @{$args->{_redirects} || []} ? (redirects => delete $args->{_redirects}) : () ),
          };
      }
      return $response;
  }

  method www_form_urlencode {
      my ($self, $data) = @_;
      (@_ == 2 && ref $data)
          or _croak(q/Usage: $http->www_form_urlencode(DATAREF)/ . "\n");
      (ref $data eq 'HASH' || ref $data eq 'ARRAY')
          or _croak("form data must be a hash or array reference\n");

      my @params = ref $data eq 'HASH' ? %$data : @$data;
      @params % 2 == 0
          or _croak("form data reference must have an even number of terms\n");

      my @terms;
      while( @params ) {
          my ($key, $value) = splice(@params, 0, 2);
          _croak("form data keys must not be undef")
              if !defined($key);
          if ( ref $value eq 'ARRAY' ) {
              unshift @params, map { $key => $_ } @$value;
          }
          else {
              push @terms, join("=", map { $self->_uri_escape($_) } $key, $value);
          }
      }

      return join("&", (ref $data eq 'ARRAY') ? (@terms) : (sort @terms) );
  }

  method can_ssl {
      my ($self) = @_;

      my($ok, $reason) = (1, '');

      # Need IO::Socket::SSL 1.42 for SSL_create_ctx_callback
      local @INC = @INC;
      pop @INC if $INC[-1] eq '.';
      unless (eval {require IO::Socket::SSL; IO::Socket::SSL->VERSION(1.42)}) {
          $ok = 0;
          $reason .= qq/IO::Socket::SSL 1.42 must be installed for https support\n/;
      }

      # Need Net::SSLeay 1.49 for MODE_AUTO_RETRY
      unless (eval {require Net::SSLeay; Net::SSLeay->VERSION(1.49)}) {
          $ok = 0;
          $reason .= qq/Net::SSLeay 1.49 must be installed for https support\n/;
      }

      # If an object, check that SSL config lets us get a CA if necessary
      if ( ref($self) && ( $self->{verify_SSL} || $self->{SSL_options}{SSL_verify_mode} ) ) {
          my $handle = HTTP::Tiny::Handle->new(
              SSL_options => $self->{SSL_options},
              verify_SSL  => $self->{verify_SSL},
          );
          unless ( eval { $handle->_find_CA_file; 1 } ) {
              $ok = 0;
              $reason .= "$@";
          }
      }

      wantarray ? ($ok, $reason) : $ok;
  }

  method connected {
      my ($self) = @_;

      if ( $self->{handle} ) {
          return $self->{handle}->connected;
      }
      return;
  }

  #--------------------------------------------------------------------------#
  # private methods
  #--------------------------------------------------------------------------#

  my %DefaultPort = (
      http => 80,
      https => 443,
  );

  method _request {
      my ($self, $method, $url, $args) = @_;

      my ($scheme, $host, $port, $path_query, $auth) = $self->_split_url($url);

      if ($scheme ne 'http' && $scheme ne 'https') {
        die(qq/Unsupported URL scheme '$scheme'\n/);
      }

      my $request = {
          method    => $method,
          scheme    => $scheme,
          host      => $host,
          port      => $port,
          host_port => ($port == $DefaultPort{$scheme} ? $host : "$host:$port"),
          uri       => $path_query,
          headers   => {},
      };

      my $peer = $args->{peer} || $host;

      # Allow 'peer' to be a coderef.
      if ('CODE' eq ref $peer) {
          $peer = $peer->($host);
      }

      # We remove the cached handle so it is not reused in the case of redirect.
      # If all is well, it will be recached at the end of _request.  We only
      # reuse for the same scheme, host and port
      my $handle = delete $self->{handle};
      if ( $handle ) {
          unless ( $handle->can_reuse( $scheme, $host, $port, $peer ) ) {
              $handle->close;
              undef $handle;
          }
      }
      $handle ||= $self->_open_handle( $request, $scheme, $host, $port, $peer );

      $self->_prepare_headers_and_cb($request, $args, $url, $auth);
      $handle->write_request($request);

      my $response;
      do { $response = $handle->read_response_header }
          until (substr($response->{status},0,1) ne '1');

      $self->_update_cookie_jar( $url, $response ) if $self->{cookie_jar};
      my @redir_args = $self->_maybe_redirect($request, $response, $args);

      my $known_message_length;
      if ($method eq 'HEAD' || $response->{status} =~ /^[23]04/) {
          # response has no message body
          $known_message_length = 1;
      }
      else {
          # Ignore any data callbacks during redirection.
          my $cb_args = @redir_args ? +{} : $args;
          my $data_cb = $self->_prepare_data_cb($response, $cb_args);
          $known_message_length = $handle->read_body($data_cb, $response);
      }

      if ( $self->{keep_alive}
          && $handle->connected
          && $known_message_length
          && $response->{protocol} eq 'HTTP/1.1'
          && ($response->{headers}{connection} || '') ne 'close'
      ) {
          $self->{handle} = $handle;
      }
      else {
          $handle->close;
      }

      $response->{success} = substr( $response->{status}, 0, 1 ) eq '2';
      $response->{url} = $url;

      # Push the current response onto the stack of redirects if redirecting.
      if (@redir_args) {
          push @{$args->{_redirects}}, $response;
          return $self->_request(@redir_args, $args);
      }

      # Copy the stack of redirects into the response before returning.
      $response->{redirects} = delete $args->{_redirects}
        if @{$args->{_redirects}};
      return $response;
  }

  method _open_handle {
      my ($self, $request, $scheme, $host, $port, $peer) = @_;

      my $handle  = HTTP::Tiny::Handle->new(
          timeout         => $self->{timeout},
          SSL_options     => $self->{SSL_options},
          verify_SSL      => $self->{verify_SSL},
          local_address   => $self->{local_address},
          keep_alive      => $self->{keep_alive}
      );

      if ($self->{_has_proxy}{$scheme} && ! grep { $host =~ /\Q$_\E$/ } @{$self->{no_proxy}}) {
          return $self->_proxy_connect( $request, $handle );
      }
      else {
          return $handle->connect($scheme, $host, $port, $peer);
      }
  }

  method _proxy_connect {
      my ($self, $request, $handle) = @_;

      my @proxy_vars;
      if ( $request->{scheme} eq 'https' ) {
          _croak(qq{No https_proxy defined}) unless $self->{https_proxy};
          @proxy_vars = $self->_split_proxy( https_proxy => $self->{https_proxy} );
          if ( $proxy_vars[0] eq 'https' ) {
              _croak(qq{Can't proxy https over https: $request->{uri} via $self->{https_proxy}});
          }
      }
      else {
          _croak(qq{No http_proxy defined}) unless $self->{http_proxy};
          @proxy_vars = $self->_split_proxy( http_proxy => $self->{http_proxy} );
      }

      my ($p_scheme, $p_host, $p_port, $p_auth) = @proxy_vars;

      if ( length $p_auth && ! defined $request->{headers}{'proxy-authorization'} ) {
          $self->_add_basic_auth_header( $request, 'proxy-authorization' => $p_auth );
      }

      $handle->connect($p_scheme, $p_host, $p_port, $p_host);

      if ($request->{scheme} eq 'https') {
          $self->_create_proxy_tunnel( $request, $handle );
      }
      else {
          # non-tunneled proxy requires absolute URI
          $request->{uri} = "$request->{scheme}://$request->{host_port}$request->{uri}";
      }

      return $handle;
  }

  method _split_proxy {
      my ($self, $type, $proxy) = @_;

      my ($scheme, $host, $port, $path_query, $auth) = eval { $self->_split_url($proxy) };

      unless(
          defined($scheme) && length($scheme) && length($host) && length($port)
          && $path_query eq '/'
      ) {
          _croak(qq{$type URL must be in format http[s]://[auth@]<host>:<port>/\n});
      }

      return ($scheme, $host, $port, $auth);
  }

  method _create_proxy_tunnel {
      my ($self, $request, $handle) = @_;

      $handle->_assert_ssl;

      my $agent = exists($request->{headers}{'user-agent'})
          ? $request->{headers}{'user-agent'} : $self->{agent};

      my $connect_request = {
          method    => 'CONNECT',
          uri       => "$request->{host}:$request->{port}",
          headers   => {
              host => "$request->{host}:$request->{port}",
              'user-agent' => $agent,
          }
      };

      if ( $request->{headers}{'proxy-authorization'} ) {
          $connect_request->{headers}{'proxy-authorization'} =
              delete $request->{headers}{'proxy-authorization'};
      }

      $handle->write_request($connect_request);
      my $response;
      do { $response = $handle->read_response_header }
          until (substr($response->{status},0,1) ne '1');

      # if CONNECT failed, throw the response so it will be
      # returned from the original request() method;
      unless (substr($response->{status},0,1) eq '2') {
          die $response;
      }

      # tunnel established, so start SSL handshake
      $handle->start_ssl( $request->{host} );

      return;
  }

  method _prepare_headers_and_cb {
      my ($self, $request, $args, $url, $auth) = @_;

      for ($self->{default_headers}, $args->{headers}) {
          next unless defined;
          while (my ($k, $v) = each %$_) {
              $request->{headers}{lc $k} = $v;
              $request->{header_case}{lc $k} = $k;
          }
      }

      if (exists $request->{headers}{'host'}) {
          die(qq/The 'Host' header must not be provided as header option\n/);
      }

      $request->{headers}{'host'}         = $request->{host_port};
      $request->{headers}{'user-agent'} ||= $self->{agent};
      $request->{headers}{'connection'}   = "close"
          unless $self->{keep_alive};

      # Some servers error on an empty-body PUT/POST without a content-length
      if ( $request->{method} eq 'PUT' || $request->{method} eq 'POST' ) {
          if (!defined($args->{content}) || !length($args->{content}) ) {
              $request->{headers}{'content-length'} = 0;
          }
      }

      if ( defined $args->{content} ) {
          if ( ref $args->{content} eq 'CODE' ) {
              if ( exists $request->{'content-length'} && $request->{'content-length'} == 0 ) {
                  $request->{cb} = method { "" };
              }
              else {
                  $request->{headers}{'content-type'} ||= "application/octet-stream";
                  $request->{headers}{'transfer-encoding'} = 'chunked'
                    unless exists $request->{headers}{'content-length'}
                    || $request->{headers}{'transfer-encoding'};
                  $request->{cb} = $args->{content};
              }
          }
          elsif ( length $args->{content} ) {
              my $content = $args->{content};
              if ( $] ge '5.008' ) {
                  utf8::downgrade($content, 1)
                      or die(qq/Wide character in request message body\n/);
              }
              $request->{headers}{'content-type'} ||= "application/octet-stream";
              $request->{headers}{'content-length'} = length $content
                unless $request->{headers}{'content-length'}
                    || $request->{headers}{'transfer-encoding'};
              $request->{cb} = method { substr $content, 0, length $content, '' };
          }
          $request->{trailer_cb} = $args->{trailer_callback}
              if ref $args->{trailer_callback} eq 'CODE';
      }

      ### If we have a cookie jar, then maybe add relevant cookies
      if ( $self->{cookie_jar} ) {
          my $cookies = $self->cookie_jar->cookie_header( $url );
          $request->{headers}{cookie} = $cookies if length $cookies;
      }

      # if we have Basic auth parameters, add them
      if ( length $auth && ! defined $request->{headers}{authorization} ) {
          $self->_add_basic_auth_header( $request, 'authorization' => $auth );
      }

      return;
  }

  method _add_basic_auth_header {
      my ($self, $request, $header, $auth) = @_;
      require MIME::Base64;
      $request->{headers}{$header} =
          "Basic " . MIME::Base64::encode_base64($auth, "");
      return;
  }

  method _prepare_data_cb {
      my ($self, $response, $args) = @_;
      my $data_cb = $args->{data_callback};
      $response->{content} = '';

      if (!$data_cb || $response->{status} !~ /^2/) {
          if (defined $self->{max_size}) {
              $data_cb = method {
                  $_[1]->{content} .= $_[0];
                  die(qq/Size of response body exceeds the maximum allowed of $self->{max_size}\n/)
                    if length $_[1]->{content} > $self->{max_size};
              };
          }
          else {
              $data_cb = method { $_[1]->{content} .= $_[0] };
          }
      }
      return $data_cb;
  }

  method _update_cookie_jar {
      my ($self, $url, $response) = @_;

      my $cookies = $response->{headers}->{'set-cookie'};
      return unless defined $cookies;

      my @cookies = ref $cookies ? @$cookies : $cookies;

      $self->cookie_jar->add( $url, $_ ) for @cookies;

      return;
  }

  method _validate_cookie_jar {
      my ($class, $jar) = @_;

      # duck typing
      for my $method ( qw/add cookie_header/ ) {
          _croak(qq/Cookie jar must provide the '$method' method\n/)
              unless ref($jar) && ref($jar)->can($method);
      }

      return;
  }

  method _maybe_redirect {
      my ($self, $request, $response, $args) = @_;
      my $headers = $response->{headers};
      my ($status, $method) = ($response->{status}, $request->{method});
      $args->{_redirects} ||= [];

      if (($status eq '303' or ($status =~ /^30[1278]/ && $method =~ /^GET|HEAD$/))
          and $headers->{location}
          and @{$args->{_redirects}} < $self->{max_redirect}
      ) {
          my $location = ($headers->{location} =~ /^\//)
              ? "$request->{scheme}://$request->{host_port}$headers->{location}"
              : $headers->{location} ;
          return (($status eq '303' ? 'GET' : $method), $location);
      }
      return;
  }

  method _split_url {
      my $url = pop;

      # URI regex adapted from the URI module
      my ($scheme, $host, $path_query) = $url =~ m<\A([^:/?#]+)://([^/?#]*)([^#]*)>
        or die(qq/Cannot parse URL: '$url'\n/);

      $scheme     = lc $scheme;
      $path_query = "/$path_query" unless $path_query =~ m<\A/>;

      my $auth = '';
      if ( (my $i = index $host, '@') != -1 ) {
          # user:pass@host
          $auth = substr $host, 0, $i, ''; # take up to the @ for auth
          substr $host, 0, 1, '';          # knock the @ off the host

          # userinfo might be percent escaped, so recover real auth info
          $auth =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
      }
      my $port = $host =~ s/:(\d*)\z// && length $1 ? $1
               : $scheme eq 'http'                  ? 80
               : $scheme eq 'https'                 ? 443
               : undef;

      return ($scheme, (length $host ? lc $host : "localhost") , $port, $path_query, $auth);
  }

  # Date conversions adapted from HTTP::Date
  my $DoW = "Sun|Mon|Tue|Wed|Thu|Fri|Sat";
  my $MoY = "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec";
  method _http_date {
      my ($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($_[1]);
      return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
          substr($DoW,$wday*4,3),
          $mday, substr($MoY,$mon*4,3), $year+1900,
          $hour, $min, $sec
      );
  }

  method _parse_http_date {
      my ($self, $str) = @_;
      require Time::Local;
      my @tl_parts;
      if ($str =~ /^[SMTWF][a-z]+, +(\d{1,2}) ($MoY) +(\d\d\d\d) +(\d\d):(\d\d):(\d\d) +GMT$/) {
          @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
      }
      elsif ($str =~ /^[SMTWF][a-z]+, +(\d\d)-($MoY)-(\d{2,4}) +(\d\d):(\d\d):(\d\d) +GMT$/ ) {
          @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
      }
      elsif ($str =~ /^[SMTWF][a-z]+ +($MoY) +(\d{1,2}) +(\d\d):(\d\d):(\d\d) +(?:[^0-9]+ +)?(\d\d\d\d)$/ ) {
          @tl_parts = ($5, $4, $3, $2, (index($MoY,$1)/4), $6);
      }
      return eval {
          my $t = @tl_parts ? Time::Local::timegm(@tl_parts) : -1;
          $t < 0 ? undef : $t;
      };
  }

  # URI escaping adapted from URI::Escape
  # c.f. http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
  # perl 5.6 ready UTF-8 encoding adapted from JSON::PP
  my %escapes = map { chr($_) => sprintf("%%%02X", $_) } 0..255;
  $escapes{' '}="+";
  my $unsafe_char = qr/[^A-Za-z0-9\-\._~]/;

  method _uri_escape {
      my ($self, $str) = @_;
      return "" if !defined $str;
      if ( $] ge '5.008' ) {
          utf8::encode($str);
      }
      else {
          $str = pack("U*", unpack("C*", $str)) # UTF-8 encode a byte string
              if ( length $str == do { use bytes; length $str } );
          $str = pack("C*", unpack("C*", $str)); # clear UTF-8 flag
      }
      $str =~ s/($unsafe_char)/$escapes{$1}/g;
      return $str;
  }


=cut
